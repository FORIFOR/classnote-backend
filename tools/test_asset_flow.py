import firebase_admin
from firebase_admin import credentials, auth
import requests
import json
import time

# --- Config ---
API_BASE_URL = "https://classnote-api-mur5rvqgga-an.a.run.app"
TEST_UID = "test-user-asset-flow" # Unique user for this test

# --- Auth ---
cred = credentials.Certificate("classnote-api-key.json")
firebase_admin.initialize_app(cred)

def get_id_token(uid):
    return auth.create_custom_token(uid).decode('utf-8') # Actually custom token needs exchange...
    # Wait, regular flow for custom token requires client SDK to exchange.
    # Let's use a real UID if we can, or just mock?
    # Actually, for backend testing with `verify_firebase_token`, we need a valid ID Token.
    # But `create_custom_token` returns a CUSTOM token, not an ID token.
    # To get an ID Token without client SDK, we can use the Identity Toolkit REST API
    # OR we can assume `auth.router` has a verify endpoint? No.
    # Easier way: Use a known valid UID and mock the token? No, server validates with Firebase Admin.
    # 
    # Alternative: Use the `print_curl_command.py` logic which likely assumes we manually got a token?
    # No, `print_curl_command.py` printed a custom token.
    #
    # Let's try to simulate a login if we have that capability, or just use the `TEST_UID` which might be allowed if we use a specific verified token.
    #
    # Actually, for these automated tests, I often struggle with Auth.
    # BUT, I see `tools/test_youtube_import_real.py` uses `requests.post` to Google Identity Toolkit to exchange custom token!
    # Let's copy that logic.
    pass

API_KEY = "YOUR_WEB_API_KEY_HERE" # Need to find this or ask user?
# I saw `tools/print_curl_command.py` had a hardcoded API Key.
# Let's read it from there if possible.

def get_exchange_token(custom_token):
    # Retrieve API Key from env or file?
    # I'll try to find it in the workspace.
    # For now, I'll attempt to construct the test without it and fail fast if needed.
    # Let's read `tools/print_curl_command.py` to get the key.
    with open("tools/print_curl_command.py", "r") as f:
        content = f.read()
        import re
        match = re.search(r'API_KEY = "([^"]+)"', content)
        if match:
            return exchange_custom_token(custom_token, match.group(1))
    return None

def exchange_custom_token(custom_token, api_key):
    url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithCustomToken?key={api_key}"
    resp = requests.post(url, json={"token": custom_token, "returnSecureToken": True})
    resp.raise_for_status()
    return resp.json()["idToken"]

# --- Test Flow ---

def run_test():
    print("--- Starting Asset Manifest Flow Test ---")
    custom_token = auth.create_custom_token(TEST_UID).decode('utf-8')
    id_token = get_exchange_token(custom_token)
    if not id_token:
        print("Failed to get ID Token. Check API Key.")
        return

    headers = {"Authorization": f"Bearer {id_token}"}

    # 0. Ping Check - Verify Router Mount
    print("\n[0] Pinging Assets Router...")
    ping_res = requests.get(f"{API_BASE_URL}/assets/ping", headers=headers)
    if ping_res.status_code == 200:
        print(f"PASS: /assets/ping -> {ping_res.json()}")
    else:
        print(f"FAIL: /assets/ping -> {ping_res.status_code} {ping_res.text}")
        # Continue anyway to see if other things fail similarly

    # 1. Create a dummy session via YouTube Import (Simulates client-side transcript)
    print("\n[1] Creating Session (YouTube Import)...")
    import_payload = {
        "url": "https://youtu.be/dummy123",
        "mode": "lecture",
        "transcriptText": "This is a dummy transcript for asset flow verification.",
        "language": "en",
        "isAutoGenerated": True
    }
    res = requests.post(f"{API_BASE_URL}/imports/youtube", json=import_payload, headers=headers)
    if res.status_code != 200:
        print(f"Failed to import: {res.text}")
        return
        
    session_id = res.json()["sessionId"]
    print(f"Session ID: {session_id}")

    # 2. Wait a bit for async tasks (Summary/Playlist) to be queued/processed?
    # Actually, import with transcript sets transcript immediately.
    # Summary/Playlist are async.
    # But transcript should be ready.

    # 3. GET /assets (Transcript should be READY)
    print("\n[2] Fetching Manifest (Initial)...")
    res = requests.get(f"{API_BASE_URL}/sessions/{session_id}/assets", headers=headers)
    manifest = res.json()
    print(json.dumps(manifest, indent=2, ensure_ascii=False))
    
    # Assert
    if manifest.get("transcript", {}).get("status") != "ready":
        print("ERROR: Transcript should be READY")
    else:
        print("PASS: Transcript is READY")
    
    # 4. POST /resolve (Should return valid URL for transcript)
    print("\n[3] Resolving Assets (Transcript)...")
    res = requests.post(f"{API_BASE_URL}/sessions/{session_id}/assets/resolve", json={"types": ["transcript"]}, headers=headers)
    resolved = res.json()
    print(json.dumps(resolved, indent=2, ensure_ascii=False))

    # Assert URL validity
    t_url = resolved["assets"].get("transcript", {}).get("url")
    if t_url:
        print(f"PASS: Got Transcript URL: {t_url}")
        # Verify content access
        # Since it uses user auth, we need to pass headers?
        # My implementation of resolve returned:
        # `https://api.../sessions/{id}/artifacts/transcript?format=json`
        # This endpoint DOES require auth.
        # So we test fetching it WITH headers.
        
        print(f"    Fetching content from URL...")
        content_res = requests.get(t_url, headers=headers)
        if content_res.status_code == 200:
            print("PASS: Content fetched successfully")
            print(f"Content: {content_res.text[:50]}...")
        else:
            print(f"FAIL: Failed to fetch content: {content_res.status_code} {content_res.text}")

    else:
        print("FAIL: No Transcript URL returned")

    # --- Step 4: Ensure Idempotency ---
    print("\n[4] Ensuring Quiz Asset (Idempotency Check)...")
    url = f"{API_BASE_URL}/sessions/{session_id}/assets/quiz/ensure"
    resp = requests.post(url, headers=headers)
    if resp.status_code == 200:
        data = resp.json()
        print(json.dumps(data, indent=2, ensure_ascii=False))
        if data.get("status") in ["enqueued", "skipped"]:
             print("PASS: Ensure endpoint returned valid status")
        else:
             print("FAIL: Unexpected ensure status")
    else:
        print(f"FAIL: {resp.status_code} {resp.text}")

    print("\n--- Test Finished ---")

if __name__ == "__main__":
    run_test()
