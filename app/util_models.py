from enum import Enum

from pydantic import BaseModel, Field
from typing import Optional, List, Any, Dict, Literal
from datetime import datetime

# --- Enums ---

class AudioStatus(str, Enum):
    PENDING = "pending"
    UPLOADING = "uploading"
    UPLOADED = "uploaded"
    PROCESSING = "processing"
    READY = "ready"
    FAILED = "failed"
    EXPIRED = "expired"
    UNKNOWN = "unknown"


class AssetStatus(str, Enum):
    READY = "ready"
    PROCESSING = "processing"
    NOT_STARTED = "not_started"  # Asset generation has not started yet
    MISSING = "missing"  # Asset is missing/unavailable
    ERROR = "error"

class AssetItem(BaseModel):
    status: AssetStatus
    version: int = 1
    updatedAt: Optional[datetime] = None
    contentType: Optional[str] = None
    sizeBytes: Optional[int] = None
    sha256: Optional[str] = None
    error: Optional[str] = None
    lockedReason: Optional[Literal["paywall", "quota", "ownerOnly"]] = None # [NEW] Plan control

class AssetManifest(BaseModel):
    # Core assets
    audio: Optional[AssetItem] = None
    transcript: Optional[AssetItem] = None
    summary: Optional[AssetItem] = None
    quiz: Optional[AssetItem] = None
    playlist: Optional[AssetItem] = None
    # Flexible Map
    images: Dict[str, AssetItem] = {}

AssetResolveType = Literal["audio", "summary", "quiz", "transcript"]

class AssetResolveRequest(BaseModel):
    types: List[AssetResolveType]

class ResolvedAsset(BaseModel):
    url: str
    headers: Dict[str, str] = {}
    expiresAt: Optional[datetime] = None
    sha256: Optional[str] = None
    version: int = 1
    contentType: Optional[str] = None
    format: Optional[str] = None # "json", "markdown", "vtt", etc.

class AssetResolveResponse(BaseModel):
    assets: Dict[str, ResolvedAsset] # key=type (or image key)

class JobStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

class TranscriptionMode(str, Enum):
    CLOUD_GOOGLE = "cloud_google"
    DEVICE_SHERPA = "device_sherpa"
    DEVICE_APPLE = "device_apple"
    DUAL_CLOUD_AND_DEVICE = "dual_cloud_and_device"

class CreateSessionRequest(BaseModel):
    title: str
    mode: str = "lecture"
    userId: Optional[str] = None  # Optional: Server uses Auth Token UID by default
    tags: Optional[List[str]] = None  # Max 4 tags
    status: Optional[str] = None  # äºˆå®š/æœªéŒ²éŸ³/éŒ²éŸ³ä¸­/éŒ²éŸ³æ¸ˆã¿/è¦ç´„æ¸ˆã¿/ãƒ†ã‚¹ãƒˆç”Ÿæˆ/ãƒ†ã‚¹ãƒˆå®Œäº†
    startAt: Optional[datetime] = None
    endAt: Optional[datetime] = None
    syncToGoogleCalendar: Optional[bool] = False
    visibility: str = "private"  # private, shared, org
    transcriptionMode: Optional[TranscriptionMode] = TranscriptionMode.CLOUD_GOOGLE
    # [OFFLINE SYNC]
    clientSessionId: Optional[str] = None
    deviceId: Optional[str] = None
    createdAt: Optional[datetime] = None
    source: str = "ios" # [NEW] Tracking origin

class UpdateSessionRequest(BaseModel):
    """PATCH éƒ¨åˆ†æ›´æ–°ã€‚æŒ‡å®šã—ãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã ã‘æ›´æ–°ã€‚"""
    title: Optional[str] = None
    tags: Optional[List[str]] = None  # Max 4 tags, empty list = clear all
    status: Optional[str] = None  # äºˆå®š/æœªéŒ²éŸ³/éŒ²éŸ³ä¸­/éŒ²éŸ³æ¸ˆã¿/è¦ç´„æ¸ˆã¿/ãƒ†ã‚¹ãƒˆç”Ÿæˆ/ãƒ†ã‚¹ãƒˆå®Œäº†
    visibility: Optional[str] = None



class TranscriptUploadRequest(BaseModel):
    text: str
    source: str # device_sherpa, device_apple, etc.
    modelInfo: Optional[Dict[str, Any]] = None
    processingTimeSec: Optional[float] = None
    isFinal: bool = True

class ImportYouTubeRequest(BaseModel):
    url: str
    mode: Literal["lecture", "meeting"] = "lecture"
    title: Optional[str] = None
    language: Optional[str] = "ja"
    transcriptText: Optional[str] = None
    transcriptLang: Optional[str] = None
    isAutoGenerated: bool = False # [NEW]


class ImportYouTubeResponse(BaseModel):
    sessionId: str
    transcriptStatus: str = "ready"
    summaryStatus: str = "pending"
    quizStatus: str = "pending"
    sourceUrl: Optional[str] = None

class RetryTranscriptionRequest(BaseModel):
    mode: str = "cloud_google" # Currently only cloud_google supported


# Reaction Models
ReactionEmoji = Literal["ðŸ”¥", "ðŸ‘", "ðŸ˜‡", "ðŸ¤¯", "ðŸ«¶"]

class SetReactionRequest(BaseModel):
    emoji: Optional[ReactionEmoji] = None

class SetReactionRequest(BaseModel):
    emoji: Optional[ReactionEmoji] = None

class ReactionStateResponse(BaseModel):
    myEmoji: Optional[str] = None
    counts: Dict[str, int] = {}
    
# Job Models
JobType = Literal["summary", "quiz", "explain", "playlist", "calendar_sync", "transcribe", "generate_highlights", "diarize", "translate", "qa"]

class JobRequest(BaseModel):
    type: JobType
    params: Dict[str, Any] = {}
    idempotencyKey: Optional[str] = None

    model_config = {"populate_by_name": True}

class JobResponse(BaseModel):
    jobId: str
    type: JobType
    status: str # JobStatus
    createdAt: datetime
    errorReason: Optional[str] = None
    result: Optional[Dict[str, Any]] = None
    progress: Optional[float] = 0.0
    pollUrl: Optional[str] = None  # Full path for polling, e.g. /sessions/{sid}/jobs/{jobId}
    transcriptText: Optional[str] = None  # [NEW] For direct access if job type is transcribe


class DiarizedSegment(BaseModel):
    """è©±è€…åˆ†é›¢ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼ˆiOS ã‚ªãƒ³ãƒ‡ãƒã‚¤ã‚¹ STT ã‹ã‚‰é€ä¿¡ï¼‰"""
    startSec: float
    endSec: float
    speakerId: Optional[str] = None
    text: str

class TranscriptUpdateRequest(BaseModel):
    """æ–‡å­—èµ·ã“ã—ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆiOS ã‹ã‚‰ transcript + segments ã‚’é€ä¿¡ï¼‰"""
    transcriptText: str
    segments: Optional[List[DiarizedSegment]] = None
    source: Optional[str] = "device"  # "device" | "cloud"
    transcriptSha256: Optional[str] = None # [OFFLINE SYNC]

class TranscriptChunkInput(BaseModel):
    id: Optional[str] = None
    startMs: Optional[float] = None
    endMs: Optional[float] = None
    speakerId: Optional[str] = None
    text: str
    kind: Optional[str] = "final"  # partial/final/batchFix
    version: Optional[int] = None

class TranscriptChunkAppendRequest(BaseModel):
    chunks: List[TranscriptChunkInput]
    source: Optional[str] = "device"
    updateSessionTranscript: bool = False
    finalize: bool = False

class TranscriptChunkReplaceRequest(BaseModel):
    chunks: List[TranscriptChunkInput]
    source: Optional[str] = "batch"
    updateSessionTranscript: bool = False

class TranscriptChunkAppendResponse(BaseModel):
    sessionId: str
    chunkIds: List[str]
    count: int
    status: JobStatus = JobStatus.COMPLETED

class VideoUrlUpdateRequest(BaseModel):
    videoUrl: str

class NotesUpdateRequest(BaseModel):
    notes: str

class BatchDeleteRequest(BaseModel):
    ids: List[str]

class DiarizationRequest(BaseModel):
    force: bool = False

class QaEnqueueResponse(BaseModel):
    qaId: str
    sessionId: str
    status: JobStatus = JobStatus.PENDING
    message: str = "QA processing started"

class QaStatusResponse(BaseModel):
    qaId: str
    sessionId: str
    status: JobStatus
    question: Optional[str] = None
    answer: Optional[str] = None
    citations: Optional[List[Any]] = None
    error: Optional[str] = None
    updatedAt: Optional[datetime] = None

class TranslateEnqueueResponse(BaseModel):
    sessionId: str
    status: JobStatus = JobStatus.PENDING
    language: str
    message: str = "Translation started"

class TranslateStatusResponse(BaseModel):
    sessionId: str
    status: JobStatus
    language: Optional[str] = None
    translatedText: Optional[str] = None
    error: Optional[str] = None
    updatedAt: Optional[datetime] = None

class StartTranscribeRequest(BaseModel):
    pass

class StartTranscribeResponse(BaseModel):
    status: JobStatus
    sessionId: str

class UploadUrlRequest(BaseModel):
    sessionId: str
    contentType: str
    # Metadata for GCS object (Optional, for enforcing x-goog-meta headers if client supports it)
    duration: Optional[float] = None
    sampleRate: Optional[int] = None
    bitrate: Optional[int] = None
    codec: Optional[str] = None
    appVersion: Optional[str] = None

class UploadUrlResponse(BaseModel):
    uploadUrl: str
    method: str
    headers: dict
    storagePath: Optional[str] = None

class AudioMeta(BaseModel):
    variant: str = "compressed" # "original" or "compressed"
    codec: str # Required: e.g. "opus", "aac"
    container: str # Required: e.g. "ogg", "m4a"
    sampleRate: int # Required
    channels: int # Required
    sizeBytes: int # Required
    payloadSha256: str # Required for integrity
    bitrate: Optional[int] = None
    durationSec: Optional[float] = None
    originalSha256: Optional[str] = None # Optional: Checksum of original audio

class AudioPrepareRequest(BaseModel):
    contentType: str
    durationSec: Optional[float] = None
    sampleRate: Optional[int] = None
    bitrate: Optional[int] = None
    codec: Optional[str] = None
    appVersion: Optional[str] = None

class AudioPrepareResponse(BaseModel):
    uploadUrl: str
    method: str
    headers: dict
    storagePath: Optional[str] = None
    deleteAfterAt: Optional[Any] = None

class AudioCommitRequest(BaseModel):
    storagePath: Optional[str] = None
    sizeBytes: Optional[int] = None
    contentType: Optional[str] = None
    durationSec: Optional[float] = None
    metadata: Optional[AudioMeta] = None
    expectedSizeBytes: int # Required for strict validation
    expectedPayloadSha256: str # Required for strict validation

class AudioCommitResponse(BaseModel):
    status: AudioStatus
    deleteAfterAt: Optional[datetime] = None

class QaRequest(BaseModel):
    question: str

class QaCitation(BaseModel):
    excerpt: Optional[str] = None
    reason: Optional[str] = None

class QaResponse(BaseModel):
    answer: str
    citations: Optional[List[QaCitation]] = None

# --- Sharing Models ---

class ShareToUserRequest(BaseModel):
    email: str

class ShareResponse(BaseModel):
    sessionId: str
    sharedUserIds: List[str]

class ShareLinkResponse(BaseModel):
    url: str

class PublicUser(BaseModel):
    uid: str
    displayName: Optional[str] = None
    username: Optional[str] = None  # [NEW]
    email: Optional[str] = None
    photoUrl: Optional[str] = None
    providers: Optional[List[str]] = None
    allowSearch: Optional[bool] = None

class ShareSessionRequest(BaseModel):
    userIds: List[str]
    revoke: bool = False

class SharedSessionDTO(BaseModel):
    sessionId: str
    title: str
    transcriptText: Optional[str] = None
    summaryMarkdown: Optional[str] = None
    ownerDisplayName: Optional[str] = None
    createdAt: Optional[datetime] = None

class ShareByCodeRequest(BaseModel):
    targetShareCode: str

# --- Session Members ---

class SharedUserSummary(BaseModel):
    uid: str
    username: Optional[str] = None
    displayName: Optional[str] = None
    photoUrl: Optional[str] = None
    isShareable: bool = True

class SessionMemberResponse(BaseModel):
    sessionId: str
    userId: str
    role: str
    joinedAt: Optional[datetime] = None
    source: Optional[str] = None
    displayNameSnapshot: Optional[str] = None
    # [NEW] Live Profile Fields
    username: Optional[str] = None
    displayName: Optional[str] = None
    photoUrl: Optional[str] = None

class SessionMemberUpdateRequest(BaseModel):
    role: str

class SessionMemberInviteRequest(BaseModel):
    userId: Optional[str] = None
    email: Optional[str] = None
    role: str = "viewer"

# --- Me / Profile Models ---

class MeResponse(BaseModel):
    id: Optional[str] = None  # iOS expects this field (alias for uid)
    uid: str
    displayName: Optional[str] = None
    username: Optional[str] = None  # [NEW]
    hasUsername: bool = False       # [NEW]
    email: Optional[str] = None
    photoUrl: Optional[str] = None
    providers: List[str] = []
    provider: Optional[str] = None
    allowSearch: bool = True
    shareCode: Optional[str] = None
    isShareable: bool = True
    plan: str = "free"
    createdAt: Optional[datetime] = None
    
    # [Security] Tracking
    securityState: str = "normal"
    riskScore: int = 0
    
    # [NEW] Free Plan Credits
    freeCloudCreditsRemaining: Optional[int] = None
    freeSummaryCreditsRemaining: Optional[int] = None
    freeQuizCreditsRemaining: Optional[int] = None
    activeSessionCount: Optional[int] = None  # For client-side paywall checks

class MeUpdateRequest(BaseModel):
    displayName: Optional[str] = None
    email: Optional[str] = None
    allowSearch: Optional[bool] = None
    isShareable: Optional[bool] = None

class UserProfileResponse(BaseModel):
    uid: str
    displayName: Optional[str] = None
    shareCode: Optional[str] = None
    isShareable: bool = True

class UserProfileUpdateRequest(BaseModel):
    displayName: Optional[str] = None
    isShareable: Optional[bool] = None

class ShareCodeResponse(BaseModel):
    shareCode: str

class ShareLookupRequest(BaseModel):
    code: str

class ClaimUsernameRequest(BaseModel):
    username: str = Field(..., description="3-20 chars: a-z0-9_")

class ShareLookupResponse(BaseModel):
    found: bool
    targetUserId: Optional[str] = None
    displayName: Optional[str] = None
    username: Optional[str] = None  # [NEW]
    photoUrl: Optional[str] = None  # [NEW] for UI

class ShareCodeLookupResponse(BaseModel):
    userId: str
    displayName: Optional[str] = None
    username: Optional[str] = None  # [NEW]
    email: Optional[str] = None
    email: Optional[str] = None

class HighlightType(str, Enum):
    important = "important"
    question = "question"
    todo = "todo"
    other = "other"

class SummaryRequest(BaseModel):
    summary: str

class TagUpdateRequest(BaseModel):
    tags: List[str]

class PlaylistItem(BaseModel):
    id: str
    title: str
    startSec: float
    endSec: float
    summary: Optional[str] = None
    label: Optional[str] = None
    segments: Optional[List[dict]] = None
    speakerId: Optional[str] = None
    snippet: Optional[str] = None
    type: Optional[str] = None
    confidence: Optional[float] = None
    order: Optional[int] = None

class PlaylistRefreshResponse(BaseModel):
    playlist: List[PlaylistItem]

class Highlight(BaseModel):
    id: str
    type: HighlightType
    startSec: float
    endSec: float
    text: str

class HighlightsResponse(BaseModel):
    highlights: List[Highlight]

class TriggerHighlightsRequest(BaseModel):
    force: bool = False

# --- Me / Profile Models ---

class ShareCodeLookupResponse(BaseModel):
    userId: str
    displayName: Optional[str] = None
    username: Optional[str] = None  # [NEW]
    email: Optional[str] = None

# --- Task & Decision Models ---

class TaskResponse(BaseModel):
    id: str
    sessionId: str
    userId: str
    title: str
    assignee: Optional[str] = None
    dueDate: Optional[str] = None
    status: str = "open"
    createdAt: Optional[datetime] = None
    source: Optional[str] = "ai"

class DecisionResponse(BaseModel):
    id: str
    sessionId: str
    content: str
    createdAt: Optional[datetime] = None

# --- Session Models ---

class SessionResponse(BaseModel):
    id: str
    clientSessionId: Optional[str] = None # [OFFLINE SYNC]
    source: Optional[str] = None # [NEW]
    title: str
    mode: str
    userId: str
    status: str
    createdAt: datetime
    tags: Optional[List[str]] = None  # User-defined tags (max 4)
    # Sharing fields
    isOwner: Optional[bool] = None
    sharedWithCount: Optional[int] = None
    sharedWithCount: Optional[int] = None
    sharedUserIds: Optional[List[str]] = []
    reactionCounts: Optional[Dict[str, int]] = {} # [NEW]
    
    # [NEW] Source of Truth fields
    ownerUserId: Optional[str] = None
    participantUserIds: List[str] = []
    participants: Optional[dict] = None  # [NEW] Map of uid -> role/joinedAt
    visibility: str = "private"
    autoTags: List[str] = []
    topicSummary: Optional[str] = None
    
    # [NEW] Job Statuses per feature
    summaryStatus: Optional[str] = "not_started"
    quizStatus: Optional[str] = "not_started"
    explainStatus: Optional[str] = "not_started"
    diarizationStatus: Optional[str] = "not_started"
    highlightsStatus: Optional[str] = "not_started"
    
    # [NEW] User specific meta fields
    isArchived: bool = False
    lastOpenedAt: Optional[datetime] = None
    
    # [NEW] Moved from Detail for Insights Calculation in Lists
    startedAt: Optional[datetime] = None
    endedAt: Optional[datetime] = None
    durationSec: Optional[float] = None
    hasTranscript: bool = False # Helper for client efficiency
    
    # [Security] Cloud Ticket System
    cloudTicket: Optional[str] = None
    cloudAllowedUntil: Optional[datetime] = None
    cloudStatus: Optional[str] = None # "none"|"allowed"|"limited"|"blocked"

class SessionMetaUpdateRequest(BaseModel):
    isPinned: Optional[bool] = None
    isArchived: Optional[bool] = None
    lastOpenedAt: Optional[datetime] = None

class SessionDetailResponse(SessionResponse):
    transcriptText: Optional[str] = None
    notes: Optional[str] = None
    assets: Optional[AssetResolveResponse] = None # For full asset paths
    googleCalendar: Optional[dict] = None # Legacy
    reactionIncr: Optional[int] = 0 # For UI optimization
    
    # Also include raw segments if needed by UI (optional)
    segments: Optional[List[dict]] = None
    diarizedSegments: Optional[List[dict]] = None
    
    # Audio availability
    audioStatus: Optional[AudioStatus] = AudioStatus.UNKNOWN
    audioMeta: Optional[AudioMeta] = None  # [NEW]
    
    # AI Results
    summaryStatus: Optional[JobStatus] = JobStatus.PENDING
    summaryError: Optional[str] = None
    summaryMarkdown: Optional[str] = None
    tags: List[str] = []
    
    quizStatus: Optional[JobStatus] = JobStatus.PENDING
    quizError: Optional[str] = None
    quizMarkdown: Optional[str] = None
    quizJson: Optional[str] = None  # JSON string of quiz data
    
    playlistStatus: Optional[JobStatus] = None # Optional, as older sessions might not have it
    playlist: Optional[List[PlaylistItem]] = None
    
    audioPath: Optional[str] = None
    speakers: Optional[List[dict]] = None
    diarizedSegments: Optional[List[dict]] = None
    
    # Flags
    hasSummary: bool = False
    hasQuiz: bool = False

# --- Auth Models ---

class LineAuthRequest(BaseModel):
    idToken: str
    nonce: Optional[str] = None

class LineAuthResponse(BaseModel):
    firebaseCustomToken: str

# --- Image Note Models ---

class ImageUploadUrlRequest(BaseModel):
    contentType: str = "image/jpeg"

class ImageUploadUrlResponse(BaseModel):
    imageId: str
    uploadUrl: str
    storagePath: Optional[str] = None
    method: str = "PUT"

class ImageNoteDTO(BaseModel):
    id: str
    url: str
    createdAt: Optional[datetime] = None

# --- Audio & Highlights Models ---

class SignedCompressedAudioResponse(BaseModel):
    audioUrl: str
    expiresAt: datetime
    compressionMetadata: Optional[AudioMeta] = None



class HighlightsResponse(BaseModel):
    status: JobStatus
    highlights: Optional[List[Highlight]] = None
    tags: Optional[List[str]] = None

class TriggerHighlightsRequest(BaseModel):
    mode: str = "fast" # "fast" or "full"
    source: str = "client"

class TagUpdateRequest(BaseModel):
    tags: List[str]

# --- Derived Generation Models ---

class DerivedEnqueueRequest(BaseModel):
    idempotencyKey: Optional[str] = None

class DerivedEnqueueResponse(BaseModel):
    status: JobStatus
    alreadyQueued: bool = False
    idempotencyKey: Optional[str] = None

class DerivedStatusResponse(BaseModel):
    status: JobStatus
    jobId: Optional[str] = None # Optional because artifact might exist without job tracking
    result: Optional[dict] = None
    updatedAt: Optional[datetime] = None
    errorReason: Optional[str] = None
    modelInfo: Optional[dict] = None
    idempotencyKey: Optional[str] = None

class PlaylistArtifactResponse(BaseModel):
    status: JobStatus
    jobId: Optional[str] = None
    updatedAt: Optional[datetime] = None
    items: Optional[List[PlaylistItem]] = None
    errorReason: Optional[str] = None
    modelInfo: Optional[dict] = None
    idempotencyKey: Optional[str] = None
    version: Optional[int] = None

# --- Playlist / Device Sync Models ---

class DeviceSyncRequest(BaseModel):
    transcriptText: Optional[str] = None
    segments: Optional[List[DiarizedSegment]] = None
    notes: Optional[str] = None
    durationSec: Optional[float] = None
    audioPath: Optional[str] = None
    audioMeta: Optional[AudioMeta] = None  # [NEW]
    needsPlaylist: bool = True
    # [OFFLINE-FIRST] Session creation fields - used when session doesn't exist yet
    createIfMissing: bool = True  # If True, create session if not found (upsert behavior)
    title: Optional[str] = None  # Required if createIfMissing and session doesn't exist
    mode: Optional[str] = "lecture"  # lecture / meeting
    transcriptionMode: Optional[TranscriptionMode] = TranscriptionMode.DEVICE_SHERPA
    deviceId: Optional[str] = None
    clientCreatedAt: Optional[datetime] = None  # Original creation timestamp from device
    source: Optional[str] = "ios"


class DeviceSyncResponse(BaseModel):
    """[OFFLINE-FIRST] Response from /device_sync endpoint"""
    status: str = "accepted"
    sessionCreated: bool = False  # True if session was created during this sync
    sessionId: str


class CapabilitiesResponse(BaseModel):
    id: str = "capabilities"  # iOS expects this field
    plan: str # "free", "pro", "basic"
    canRealtimeTranslate: bool
    sttPostEngine: str # "whisper_large_v3", "gcp_speech", "none"
    monthlyRecordingLimitMin: int
    remainingRecordingMin: int
    canRegenerateTranscript: bool
    maxSessions: Optional[int] = None # None means unlimited
    maxSummaries: Optional[int] = None
    maxQuizzes: Optional[int] = None

class SubscriptionVerifyRequest(BaseModel):
    isSubscribed: bool
    originalTransactionId: Optional[str] = None
    productId: Optional[str] = None
    purchaseDate: Optional[datetime] = None
    expirationDate: Optional[datetime] = None
    environment: Optional[str] = None # "Sandbox", "Production"
    maxImageNotes: int = 3
    transactionId: Optional[str] = None
    signedTransactionInfo: Optional[str] = None
    receipt_data: Optional[str] = None

class BillingConfirmRequest(BaseModel):
    signedTransaction: str

class AppStoreNotificationRequest(BaseModel):
    signedPayload: str

class BillingConfirmResponse(BaseModel):
    ok: bool
    plan: str
    status: str
    entitled: bool
    expiresAt: Optional[int] = None # Timestamp (ms)
    originalTransactionId: Optional[str] = None
    transactionId: Optional[str] = None
    productId: Optional[str] = None
    requestId: str

class EntitlementResponse(BaseModel):
    entitled: bool
    plan: str # free, basic, pro
    expiresAt: Optional[int] = None # Timestamp in ms

# --- Quiz Analytics Models ---

class QuizAttemptCreate(BaseModel):
    quizVersion: int = 1
    total: int
    answered: int
    correct: int
    durationSec: float
    completed: bool
    answers: Optional[Dict[str, str]] = None

class QuizAttempt(QuizAttemptCreate):
    id: str
    sessionId: str
    createdAt: datetime
    userId: str

class QuizAnalytics(BaseModel):
    attempts: int
    completedAttempts: int
    completionRate: float
    avgAccuracy: float
    avgAnswered: float
    sessionsWithQuiz: int = 0
    sessionsTested: int = 0

class SessionQuizStat(BaseModel):
    sessionId: str
    title: str
    createdAt: datetime
    attemptsCount: int
    bestAccuracy: Optional[float] = None
    lastAccuracy: Optional[float] = None
    completionRate: Optional[float] = None
    lastAttemptAt: Optional[datetime] = None
